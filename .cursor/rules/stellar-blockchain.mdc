---
description: Stellar blockchain integration patterns with Stellar SDK v11+ and Wallet Kit
globs: "*.ts, *.tsx, *.stellar.ts, *.contract.ts"
---

# Stellar Blockchain Rules

Integration patterns for Stellar SDK v11+ with Effect-TS and Stellar Wallets Kit.

## Dependencies

```json
{
  "dependencies": {
    "@stellar/stellar-sdk": "^11.0.0",
    "@stellar/wallets-kit": "^1.0.0"
  }
}
```

## Network Configuration

```typescript
import { Networks, Horizon, SorobanRpc } from "@stellar/stellar-sdk"
import { Effect, Context, Layer } from "effect"

export interface StellarConfig {
  readonly network: "testnet" | "mainnet" | "futurenet"
  readonly horizonUrl: string
  readonly sorobanUrl: string
  readonly passphrase: string
}

export const StellarConfig = Context.GenericTag<StellarConfig>("@dreadnought/StellarConfig")

export const StellarConfigTestnet = Layer.succeed(StellarConfig, {
  network: "testnet",
  horizonUrl: "https://horizon-testnet.stellar.org",
  sorobanUrl: "https://soroban-testnet.stellar.org",
  passphrase: Networks.TESTNET
})

export const StellarConfigMainnet = Layer.succeed(StellarConfig, {
  network: "mainnet", 
  horizonUrl: "https://horizon.stellar.org",
  sorobanUrl: "https://soroban.stellar.org",
  passphrase: Networks.PUBLIC
})
```

## Wallet Integration with Stellar Wallets Kit

```typescript
import { 
  WalletsKit, 
  WalletType, 
  allowAllModules,
  FREIGHTER_ID,
  ALBEDO_ID,
  XBULL_ID 
} from "@stellar/wallets-kit"

// Configure supported wallets
const walletsKit = new WalletsKit({
  network: "testnet", // or "mainnet"
  selectedWalletId: FREIGHTER_ID,
  modules: allowAllModules([
    {
      id: FREIGHTER_ID,
      name: "Freighter",
      url: "https://www.freighter.app/"
    },
    {
      id: ALBEDO_ID, 
      name: "Albedo",
      url: "https://albedo.link/"
    },
    {
      id: XBULL_ID,
      name: "xBull Wallet", 
      url: "https://xbull.app/"
    }
  ])
})

// Wallet service with Effect-TS
export interface WalletService {
  readonly connect: () => Effect.Effect<string, WalletError>
  readonly disconnect: () => Effect.Effect<void, never>
  readonly signTransaction: (xdr: string) => Effect.Effect<string, WalletError>
  readonly getPublicKey: () => Effect.Effect<string, WalletError>
}

export const WalletService = Context.GenericTag<WalletService>("@dreadnought/WalletService")

export const WalletServiceLive = Layer.succeed(WalletService, {
  connect: () => pipe(
    Effect.tryPromise({
      try: async () => {
        await walletsKit.openModal()
        return walletsKit.getPublicKey()
      },
      catch: (error) => new WalletError({
        type: "CONNECTION_FAILED",
        message: error.message
      })
    })
  ),
  
  disconnect: () => Effect.sync(() => walletsKit.disconnect()),
  
  signTransaction: (xdr) => pipe(
    Effect.tryPromise({
      try: () => walletsKit.sign({ xdr }),
      catch: (error) => new WalletError({
        type: "SIGN_FAILED",
        message: error.message
      })
    })
  ),
  
  getPublicKey: () => pipe(
    Effect.tryPromise({
      try: () => walletsKit.getPublicKey(),
      catch: (error) => new WalletError({
        type: "PUBLIC_KEY_FAILED", 
        message: error.message
      })
    })
  )
})
```

## Account Operations

```typescript
import { Keypair, Account, Asset, Operation, TransactionBuilder } from "@stellar/stellar-sdk"

// Create new account
export const createAccount = (): Effect.Effect<
  { publicKey: string; secretKey: string },
  never
> =>
  Effect.sync(() => {
    const keypair = Keypair.random()
    return {
      publicKey: keypair.publicKey(), 
      secretKey: keypair.secret()
    }
  })

// Load account from network
export const loadAccount = (publicKey: string): Effect.Effect<Account, NetworkError> =>
  pipe(
    StellarConfig,
    Effect.flatMap(config =>
      Effect.tryPromise({
        try: () => new Horizon.Server(config.horizonUrl).loadAccount(publicKey),
        catch: (error) => new NetworkError({
          cause: error,
          operation: "loadAccount"
        })
      })
    )
  )

// Build payment transaction
export const buildPayment = (params: {
  source: string
  destination: string
  amount: string
  asset?: Asset
  memo?: string
}): Effect.Effect<Transaction, BuildError> =>
  pipe(
    loadAccount(params.source),
    Effect.flatMap(sourceAccount =>
      pipe(
        StellarConfig,
        Effect.map(config =>
          new TransactionBuilder(sourceAccount, {
            fee: BASE_FEE,
            networkPassphrase: config.passphrase
          })
            .addOperation(
              Operation.payment({
                destination: params.destination,
                asset: params.asset || Asset.native(),
                amount: params.amount
              })
            )
            .setTimeout(30)
            .build()
        )
      )
    )
  )
```

## Soroban Smart Contracts

```typescript
import { Contract, SorobanRpc, Address, nativeToScVal, scValToNative } from "@stellar/stellar-sdk"

// Contract interaction with Effect-TS
export const callContract = (params: {
  contractId: string
  method: string
  args: any[]
  source: string
}): Effect.Effect<any, ContractError> =>
  pipe(
    StellarConfig,
    Effect.flatMap(config =>
      Effect.tryPromise({
        try: async () => {
          const server = new SorobanRpc.Server(config.sorobanUrl)
          const contract = new Contract(params.contractId)
          
          // Convert arguments to ScVal
          const scArgs = params.args.map(arg => nativeToScVal(arg))
          
          // Build contract call
          const account = await server.getAccount(params.source)
          const operation = contract.call(params.method, ...scArgs)
          
          const tx = new TransactionBuilder(account, {
            fee: BASE_FEE,
            networkPassphrase: config.passphrase
          })
            .addOperation(operation)
            .setTimeout(30)
            .build()
          
          // Simulate and prepare
          const simulated = await server.simulateTransaction(tx)
          if (SorobanRpc.Api.isSimulationError(simulated)) {
            throw new Error(`Simulation failed: ${simulated.error}`)
          }
          
          const prepared = SorobanRpc.assembleTransaction(tx, simulated)
          return scValToNative(simulated.result?.retval)
        },
        catch: (error) => new ContractError({
          contractId: params.contractId,
          operation: params.method,
          cause: error
        })
      })
    )
  )
```

## Error Types

```typescript
import * as S from "@effect/schema/Schema"

export class NetworkError extends S.TaggedError<NetworkError>()(
  "NetworkError",
  {
    cause: S.Unknown,
    operation: S.String
  }
) {}

export class WalletError extends S.TaggedError<WalletError>()(
  "WalletError",
  {
    type: S.Literal("CONNECTION_FAILED", "SIGN_FAILED", "PUBLIC_KEY_FAILED"),
    message: S.String
  }
) {}

export class ContractError extends S.TaggedError<ContractError>()(
  "ContractError",
  {
    contractId: S.String,
    operation: S.String,
    cause: S.Unknown
  }
) {}

export class BuildError extends S.TaggedError<BuildError>()(
  "BuildError",
  {
    message: S.String,
    cause: S.optional(S.Unknown)
  }
) {}
```

## Best Practices

- Use Stellar Wallets Kit for multi-wallet support
- Always simulate Soroban transactions before submission  
- Handle network errors with proper retry logic
- Use branded types for public keys and amounts
- Wrap all async operations in Effect.tryPromise
- Configure proper fees based on network conditions
- Validate all inputs with @effect/schema
- Use testnet for development and testing

## DO NOT

- ❌ Store private keys in code or localStorage
- ❌ Use synchronous operations for network calls
- ❌ Ignore transaction fees and network congestion
- ❌ Mix testnet and mainnet configurations
- ❌ Submit unsigned transactions
- ❌ Trust user input without validation
- ❌ Use deprecated SDK methods