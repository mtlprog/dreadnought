---
description: Common code snippets and patterns for rapid development with Effect-TS and Stellar
globs: "*.ts, *.tsx"
---

# Code Snippets & Patterns

Ready-to-use code snippets for common patterns in the monorepo.

## Effect-TS Snippets

### Effect Function (eff)
```typescript
export const ${1:functionName} = (${2:params}): Effect.Effect<${3:Success}, ${4:Error}> =>
  pipe(
    ${5:Effect.succeed(null)},
    Effect.tap(() => Effect.log("${1:functionName} executed"))
  )
```

### Effect Service (eservice)
```typescript
export interface ${1:ServiceName} {
  readonly ${2:method}: (${3:params}) => Effect.Effect<${4:Result}, ${5:Error}>
}

export const ${1:ServiceName} = Context.GenericTag<${1:ServiceName}>("@dreadnought/${1:ServiceName}")

export const ${1:ServiceName}Live = Layer.succeed(${1:ServiceName}, {
  ${2:method}: (${3:params}) => pipe(
    ${6:Effect.succeed(null)},
    Effect.tap(() => Effect.log("${2:method} called"))
  )
})
```

### Effect Error (eerror)
```typescript
export class ${1:ErrorName} extends S.TaggedError<${1:ErrorName}>()(
  "${1:ErrorName}",
  {
    ${2:field}: S.${3:String},
    message: S.String,
    cause: S.optional(S.Unknown)
  }
) {}
```

### Effect Repository (erepo)
```typescript
export interface ${1:EntityName}Repository {
  readonly findById: (id: ${2:IdType}) => Effect.Effect<${1:EntityName}, NotFoundError>
  readonly create: (data: Create${1:EntityName}) => Effect.Effect<${1:EntityName}, ValidationError>
  readonly update: (id: ${2:IdType}, data: Update${1:EntityName}) => Effect.Effect<${1:EntityName}, NotFoundError>
  readonly delete: (id: ${2:IdType}) => Effect.Effect<void, NotFoundError>
}

export const ${1:EntityName}Repository = Context.GenericTag<${1:EntityName}Repository>("${1:EntityName}Repository")

export const ${1:EntityName}RepositoryLive = Layer.effect(
  ${1:EntityName}Repository,
  Effect.gen(function* () {
    const sql = yield* Sql.client.Client
    return {
      findById: (id) => pipe(
        sql\`SELECT * FROM ${3:table_name} WHERE id = \${id}\`,
        Effect.map(rows => rows[0]),
        Effect.filterOrFail(Boolean, () => new NotFoundError({ id })),
        Effect.flatMap(S.decodeUnknown(${1:EntityName}))
      ),
      create: (data) => pipe(
        S.decodeUnknown(Create${1:EntityName})(data),
        Effect.flatMap(validated => sql\`INSERT INTO ${3:table_name} \${sql.insert(validated)} RETURNING *\`),
        Effect.map(rows => rows[0]),
        Effect.flatMap(S.decodeUnknown(${1:EntityName}))
      )
    }
  })
)
```

### HTTP Route (eroute)
```typescript
const ${1:routeName} = Router.${2:get}(
  "${3:/api/route}",
  Effect.gen(function* () {
    const params = yield* Http.request.RouteParams
    const service = yield* ${4:ServiceName}
    const result = yield* service.${5:method}(params.id)
    return Http.response.json(result)
  }).pipe(
    Effect.catchTag("NotFoundError", () =>
      Effect.succeed(Http.response.json({ error: "Not found" }, { status: 404 }))
    )
  )
)
```

## React Snippets

### React Component (rce)
```typescript
"use client"

import { cn } from "@dreadnought/utils/cn"

export interface ${1:ComponentName}Props {
  className?: string
  children?: React.ReactNode
}

export function ${1:ComponentName}({ className, children, ...props }: ${1:ComponentName}Props) {
  return (
    <div className={cn("border-2 border-border bg-card p-4", className)} {...props}>
      {children}
    </div>
  )
}
```

### React Hook (rhook)
```typescript
import { useState, useCallback } from "react"
import { Effect, Runtime } from "effect"

export function use${1:HookName}() {
  const [${2:value}, set${2:Value}] = useState<${3:ValueType}>(${4:initialValue})
  const [loading, setLoading] = useState(false)
  const [error, setError] = useState<Error | null>(null)
  
  const ${5:action} = useCallback(() => {
    const runtime = Runtime.defaultRuntime
    setLoading(true)
    setError(null)
    
    runtime.runPromise(
      pipe(
        ${6:Effect.succeed(null)},
        Effect.tap(result => Effect.sync(() => set${2:Value}(result))),
        Effect.tapError(error => Effect.sync(() => setError(error))),
        Effect.ensuring(Effect.sync(() => setLoading(false)))
      )
    )
  }, [])
  
  return { ${2:value}, loading, error, ${5:action} }
}
```

### React Provider (rprovider)
```typescript
"use client"

import { createContext, useContext, type ReactNode } from "react"
import { Runtime, Layer } from "effect"

const ${1:ProviderName}Context = createContext<{ runtime: Runtime.Runtime<${2:Requirements}> } | null>(null)

export function ${1:ProviderName}({ children, layers }: { children: ReactNode; layers: Layer.Layer<${2:Requirements}> }) {
  const runtime = Runtime.make(layers)
  return (
    <${1:ProviderName}Context.Provider value={{ runtime }}>
      {children}
    </${1:ProviderName}Context.Provider>
  )
}

export function use${1:ProviderName}() {
  const context = useContext(${1:ProviderName}Context)
  if (!context) throw new Error("use${1:ProviderName} must be used within ${1:ProviderName}")
  return context
}
```

## Stellar Snippets

### Create Account (stellar-account)
```typescript
export const createAccount = (): Effect.Effect<{ publicKey: string; secretKey: string }, never> =>
  Effect.sync(() => {
    const keypair = Keypair.random()
    return {
      publicKey: keypair.publicKey(),
      secretKey: keypair.secret()
    }
  })
```

### Build Payment (stellar-payment)
```typescript
export const buildPayment = (params: {
  source: string
  destination: string
  amount: string
}): Effect.Effect<Transaction, NetworkError> =>
  pipe(
    loadAccount(params.source),
    Effect.map(sourceAccount =>
      new TransactionBuilder(sourceAccount, {
        fee: BASE_FEE,
        networkPassphrase: Networks.TESTNET
      })
        .addOperation(Operation.payment({
          destination: params.destination,
          asset: Asset.native(),
          amount: params.amount
        }))
        .setTimeout(30)
        .build()
    )
  )
```

### Soroban Contract Call (stellar-contract)
```typescript
export const callContract = (params: {
  contractId: string
  method: string
  args: any[]
  source: string
}): Effect.Effect<any, ContractError> =>
  pipe(
    Effect.tryPromise({
      try: async () => {
        const server = new SorobanRpc.Server(SOROBAN_URL)
        const contract = new Contract(params.contractId)
        const scArgs = params.args.map(arg => nativeToScVal(arg))
        const account = await server.getAccount(params.source)
        
        const operation = contract.call(params.method, ...scArgs)
        const tx = new TransactionBuilder(account, { fee: BASE_FEE, networkPassphrase: Networks.TESTNET })
          .addOperation(operation)
          .setTimeout(30)
          .build()
        
        const simulated = await server.simulateTransaction(tx)
        return scValToNative(simulated.result?.retval)
      },
      catch: (error) => new ContractError({ contractId: params.contractId, operation: params.method, cause: error })
    })
  )
```

## Database Snippets

### SQL Query (sql-query)
```typescript
export const ${1:queryName} = (${2:params}): Effect.Effect<${3:Result}[], DatabaseError> =>
  pipe(
    Sql.client.Client,
    Effect.flatMap(sql => sql\`SELECT * FROM ${4:table} WHERE ${5:condition} = \${${2:params}}\`),
    Effect.flatMap(rows => Effect.forEach(rows, S.decodeUnknown(${3:Result})))
  )
```

### SQL Transaction (sql-transaction)
```typescript
export const ${1:transactionName} = (${2:params}): Effect.Effect<${3:Result}, DatabaseError> =>
  pipe(
    Sql.client.Client,
    Effect.flatMap(sql =>
      sql.withTransaction(tx =>
        Effect.gen(function* () {
          yield* tx\`INSERT INTO ${4:table1} VALUES (\${${2:params}})\`
          const result = yield* tx\`UPDATE ${5:table2} SET ${6:column} = \${${2:params}} RETURNING *\`
          return result[0]
        })
      )
    ),
    Effect.flatMap(S.decodeUnknown(${3:Result}))
  )
```

## Testing Snippets

### Bun Test (test-effect)
```typescript
import { describe, test, expect } from "bun:test"
import { Effect, Layer } from "effect"

describe("${1:TestSuite}", () => {
  const TestLayer = Layer.merge(${2:ServiceLayer}, ${3:MockLayer})
  const runtime = Runtime.make(TestLayer)
  
  test("${4:should test something}", async () => {
    const result = await pipe(${5:effectToTest}, runtime.runPromise)
    expect(result).toBe(${6:expectedValue})
  })
  
  test("${7:should handle errors}", async () => {
    const error = await pipe(${8:effectWithError}, Effect.flip, runtime.runPromise)
    expect(error._tag).toBe("${9:ErrorTag}")
  })
})
```

### Mock Service (test-mock)
```typescript
export const Mock${1:ServiceName} = Layer.succeed(${1:ServiceName}, {
  ${2:method}: mock((${3:params}) => Effect.succeed(${4:mockResult})),
  ${5:anotherMethod}: mock(() => Effect.fail(new ${6:ErrorType}({ message: "Mock error" })))
})
```

## Utility Snippets

### Pipe Pattern (pipe)
```typescript
pipe(
  ${1:initialValue},
  Effect.map(${2:transform}),
  Effect.flatMap(${3:operation}),
  Effect.tap(() => Effect.log("${4:message}")),
  Effect.catchTag("${5:ErrorTag}", ${6:handleError})
)
```

### Schema (schema)
```typescript
export const ${1:SchemaName} = S.Struct({
  id: S.String.pipe(S.brand("${2:IdType}")),
  ${3:field}: S.${4:String},
  ${5:optionalField}: S.optional(S.${6:Number}),
  createdAt: S.Date
})

export type ${1:SchemaName} = S.Schema.Type<typeof ${1:SchemaName}>
```

### Branded Type (brand)
```typescript
export type ${1:TypeName} = ${2:string} & Brand.Brand<"${1:TypeName}">
export const ${1:TypeName} = Brand.refined<${1:TypeName}>(
  (value): value is ${1:TypeName} => ${3:validation},
  (value) => Brand.error(\`Invalid ${1:TypeName}: \${value}\`)
)
```

### Runtime (runtime)
```typescript
const runtime = pipe(
  Layer.mergeAll(${1:ConfigLayer}, ${2:DatabaseLayer}, ${3:ServiceLayer}),
  Runtime.make
)

export const run${4:ProgramName} = <A, E>(effect: Effect.Effect<A, E>) => runtime.runPromise(effect)
```

## Common Patterns

### Retry with backoff
```typescript
Effect.retry({ schedule: Schedule.exponential(Duration.millis(100)), times: 3 })
```

### Timeout
```typescript
Effect.timeout(Duration.seconds(30))
```

### Parallel execution
```typescript
Effect.all([${1:effect1}, ${2:effect2}], { concurrency: "unbounded" })
```

### Fork and join
```typescript
Effect.gen(function* () {
  const fiber = yield* Effect.fork(${1:longRunningEffect})
  const result = yield* Fiber.join(fiber)
  return result
})
```

