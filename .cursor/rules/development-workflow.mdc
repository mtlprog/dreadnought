---
title: Development Workflow
description: Complete workflow for feature development from requirements gathering to implementation
category: Development Process
priority: critical
---

# Development Workflow

This rule defines the complete workflow for adding new features to the monorepo, ensuring proper requirements gathering, code reuse, and maintaining package integrity.

## Core Principles

1. **Requirements First** - Always clarify and understand the complete picture before coding
2. **Reuse Over Rebuild** - Maximize code reuse from existing packages
3. **Apps First, Packages Later** - Develop in `/apps`, migrate to `/packages` only when explicitly requested
4. **Test-Driven Package Evolution** - All package changes must maintain backward compatibility and pass tests

## Phase 1: Requirements Gathering

### MANDATORY: Clarification Process

Before writing any code, you MUST follow this clarification process:

1. **Ask clarifying questions** about the feature requirements
2. **Identify all functional requirements** - what exactly needs to be built
3. **Understand the context** - how it fits into the existing system
4. **Clarify edge cases** - what should happen in error scenarios
5. **Confirm UI/UX expectations** - visual design, user interactions
6. **Identify integrations** - blockchain, external APIs, other services

### Question Format

Use **free-form dialogue** with the user:
- Ask specific questions about unclear aspects
- Request examples or scenarios if needed
- Clarify technical constraints or preferences
- Continue asking until you have a complete picture

**Do NOT proceed with implementation until all questions are answered.**

Example questions:
```
- "Should this feature work for all user types or specific roles?"
- "What should happen if the blockchain transaction fails?"
- "Do you want real-time updates or is polling acceptable?"
- "Should this data persist between sessions?"
```

## Phase 2: Package Analysis

### MANDATORY: Check Existing Packages

Before starting development, you MUST:

1. **Read `/packages/README.md`** to understand available packages
2. **Analyze existing packages** for potential code reuse
3. **Identify overlapping functionality** that can be leveraged
4. **Document any new packages** you discover during analysis

### Package Analysis Format

For each relevant package, provide:
- **Purpose**: One-two sentence description of what it does
- **Key Features**: Main functionality available
- **Reuse Potential**: How it relates to current feature

## Phase 3: Implementation Strategy

### Development Location Rules

**ALWAYS develop new features in `/apps` first:**

```
✅ Create new app in /apps/[feature-name]
✅ Implement all functionality within the app
✅ Use existing packages from /packages when possible
✅ Create app-specific components and services

❌ DO NOT create new packages in /packages
❌ DO NOT modify existing packages without explicit user permission
❌ DO NOT move code to /packages until user requests it
```

### Using Existing Packages

When using existing packages:

1. **Test-First Approach**: Ensure existing tests pass
2. **Backward Compatibility**: Any modifications must not break existing functionality
3. **Write Missing Tests**: If no tests exist, create them to document current behavior
4. **Version Safely**: Use semantic versioning for package updates

### Package Modification Process

If you need to modify an existing package:

```typescript
// 1. First, write tests for current behavior
describe("ExistingService", () => {
  test("should maintain existing behavior", () => {
    // Test current functionality
  })
})

// 2. Implement changes while maintaining API compatibility
// 3. Ensure all tests pass
// 4. Add tests for new functionality
```

## Phase 4: Package Evolution

### When Code Moves to Packages

Code only moves from `/apps` to `/packages` when:
- **User explicitly requests it**
- Code has proven stable and reusable
- Proper testing is in place

### Package Dependencies

**Allowed Dependencies:**
```
✅ packages → packages (managed carefully)
✅ apps → packages
✅ apps → apps (if needed)

❌ packages → apps (FORBIDDEN - breaks architecture)
```

### Package Documentation

All packages must be documented in `/packages/README.md`:

```markdown
## @dreadnought/package-name

**Purpose**: Brief description of what this package does

**Key Features**:
- Feature 1
- Feature 2

**Dependencies**: List of other packages it depends on

**Used By**: List of apps/packages that use this
```

## Development Checklist

### Before Starting Implementation

- [ ] All requirements clarified with user
- [ ] Existing packages analyzed for reuse potential
- [ ] Implementation strategy defined
- [ ] Target app location chosen

### During Implementation

- [ ] Using existing packages where possible
- [ ] All package modifications include tests
- [ ] No new packages created without user approval
- [ ] Following Effect-TS patterns consistently

### After Implementation

- [ ] All functionality working as specified
- [ ] Tests passing for any modified packages
- [ ] Documentation updated if packages modified
- [ ] Ready for user review and potential package extraction

## Common Scenarios

### Scenario: Similar Functionality Exists in Package

1. **Analyze the existing package** - can it be extended?
2. **Write tests** for current behavior if missing
3. **Propose modification** to user before implementing
4. **Extend package** maintaining backward compatibility
5. **Add tests** for new functionality

### Scenario: Need New Reusable Component

1. **Implement in app first** - get it working
2. **Wait for user directive** to extract to package
3. **Do not proactively suggest** moving to packages
4. **Focus on app functionality** until explicitly told otherwise

### Scenario: Breaking Change Needed in Package

1. **Document the breaking change** clearly
2. **Discuss with user** before implementing
3. **Plan migration strategy** for existing apps
4. **Update all affected dependencies**
5. **Update documentation**

## Anti-Patterns to Avoid

❌ **Assuming requirements** - always ask if unclear
❌ **Creating packages prematurely** - develop in apps first
❌ **Modifying packages without tests** - test coverage is mandatory
❌ **Breaking backward compatibility** - maintain existing APIs
❌ **Creating circular dependencies** - packages should not depend on apps

## Integration with Other Rules

This workflow integrates with:
- **Project Structure**: Follows monorepo organization principles
- **Effect-TS Usage**: All new code uses Effect patterns
- **Testing Strategy**: Test-driven package evolution
- **Git Workflow**: Trunk-based development with proper commits

Remember: **The goal is sustainable, reusable code that grows thoughtfully from proven app implementations.**