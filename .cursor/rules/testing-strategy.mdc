---
description: Testing patterns and strategies using Bun test runner and Effect testing utilities
globs: "*.test.ts, *.test.tsx, test-utils.ts"
---

# Testing Strategy Rules

Testing approach using Bun's test runner and Effect-TS testing utilities.

## Test File Organization

Place test files next to the code they test:

```
packages/[package-name]/src/
├── services/
│   ├── user.service.ts
│   └── user.service.test.ts    # ← Unit tests next to code
├── components/
│   ├── Button.tsx
│   └── Button.test.tsx         # ← Component tests next to code
└── test-utils/
    ├── setup.ts                # Test setup and helpers
    └── fixtures.ts             # Test data fixtures
```

## Bun Test Configuration

```toml
# bunfig.toml
[test]
preload = ["./src/test-utils/setup.ts"]
coverage = true
coverageThreshold = { line = 80 }
```

## Test Utilities

```typescript
// src/test-utils/setup.ts
import { Runtime, Layer, Effect, TestContext } from "effect"

export const createTestRuntime = <R>(layer: Layer.Layer<R, never, never>) =>
  Runtime.make(Layer.merge(layer, TestContext.TestContext))

export const runTest = <A, E>(
  effect: Effect.Effect<A, E>,
  runtime: Runtime.Runtime<any>
) => runtime.runPromise(effect)
```

## Unit Testing with Bun

```typescript
// user.service.test.ts (next to user.service.ts)
import { describe, test, expect, mock } from "bun:test"
import { Effect, Layer, TestContext } from "effect"
import { UserService, UserServiceLive } from "./user.service"

describe("UserService", () => {
  const TestLayer = Layer.merge(
    Layer.succeed(DatabaseService, {
      query: mock(() => Effect.succeed([]))
    }),
    UserServiceLive
  )
  
  const runtime = Runtime.make(TestLayer)
  
  test("should create user", async () => {
    const result = await pipe(
      UserService.create({ email: "test@test.com", name: "Test" }),
      runtime.runPromise
    )
    
    expect(result.email).toBe("test@test.com")
  })
  
  test("should handle errors", async () => {
    const error = await pipe(
      UserService.create({ email: "invalid" }),
      Effect.flip,
      runtime.runPromise
    )
    
    expect(error._tag).toBe("ValidationError")
  })
})
```

## React Component Testing

```typescript
// Button.test.tsx (next to Button.tsx)
import { test, expect } from "bun:test"
import { render, fireEvent } from "@testing-library/react"
import { Button } from "./Button"

test("renders button with text", () => {
  const { getByText } = render(<Button>Click me</Button>)
  expect(getByText("Click me")).toBeDefined()
})

test("handles click events", () => {
  let clicked = false
  const { getByRole } = render(
    <Button onClick={() => { clicked = true }}>Click</Button>
  )
  
  fireEvent.click(getByRole("button"))
  expect(clicked).toBe(true)
})
```

## Test Fixtures

```typescript
// test-utils/fixtures.ts
export const createUserFixture = (overrides?: Partial<User>) => ({
  id: "user-1",
  email: "test@example.com",
  name: "Test User",
  createdAt: new Date(),
  ...overrides
})

export const createStellarAccountFixture = () => ({
  publicKey: "GABC123...",
  secretKey: "SABC123...",
  balance: "100.0000000"
})
```

## Mocking Patterns

```typescript
// Mock services for testing
export const MockUserService = Layer.succeed(UserService, {
  create: mock((data) => Effect.succeed({ id: "1", ...data })),
  findById: mock((id) => Effect.succeed(createUserFixture({ id }))),
  delete: mock(() => Effect.void)
})

// Mock network requests
import { http, HttpResponse } from "msw"
import { setupServer } from "msw/node"

export const server = setupServer(
  http.get("/api/users", () => {
    return HttpResponse.json([createUserFixture()])
  })
)
```

## E2E Testing

```typescript
// e2e/auth.spec.ts
import { test, expect } from "@playwright/test"

test("user authentication flow", async ({ page }) => {
  await page.goto("/login")
  await page.fill('[name="email"]', "test@example.com")
  await page.fill('[name="password"]', "password")
  await page.click('[type="submit"]')
  await page.waitForURL("/dashboard")
  expect(page.url()).toContain("/dashboard")
})
```

## Best Practices

- Place tests next to the code they test (*.test.ts)
- Use Effect.flip to test error cases
- Mock external dependencies in unit tests
- Use TestContext for time-based testing
- Keep tests independent and isolated
- Use descriptive test names
- Follow AAA pattern: Arrange, Act, Assert
- Aim for 80%+ test coverage

## Test Scripts

```json
{
  "scripts": {
    "test": "bun test",
    "test:watch": "bun test --watch", 
    "test:coverage": "bun test --coverage"
  }
}
```

## DO NOT

- ❌ Use async/await in tests - use Effect.runPromise
- ❌ Share state between tests
- ❌ Test implementation details
- ❌ Make real API calls in unit tests
- ❌ Use setTimeout - use TestClock instead