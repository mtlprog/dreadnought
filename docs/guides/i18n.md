# Internationalization (i18n) with Effect-TS and SSR

Complete guide for implementing type-safe internationalization in Next.js 15 applications using Effect-TS with full SSR support.

## Overview

### Why Custom Effect-TS i18n?

Instead of using libraries like `next-intl` or `react-i18next`, Dreadnought implements a **custom Effect-TS-based i18n solution** that:

- ✅ **Type-safe translations** with Effect schema validation
- ✅ **Functional error handling** using Effect error types
- ✅ **SSR-first** - No flash on page load, cookies with next/headers
- ✅ **Cookie-based persistence** with long expiration
- ✅ **Nested translation keys** with dot notation (`"hero.title"`)
- ✅ **No external i18n dependencies** - full control over implementation
- ✅ **Consistent with Dreadnought Effect-TS patterns**
- ✅ **Browser locale detection** with fallback strategies

### Supported Features

- Multiple locale support (e.g., `en`, `ru`, `es`)
- Server-side rendering with cookies
- Nested JSON translation files
- Server and client component support
- Type-safe locale values using Effect Schema
- Smooth UI updates without page reload
- Current locale display in UI

## Architecture

```
┌─────────────────────────────────────────────────────────────┐
│                     Client Component                         │
│                  LanguageSelector.tsx                        │
│  - Uses Effect-TS via runClientEffect()                     │
│  - Imports from settings-client.ts                          │
└─────────────────────────────────────────────────────────────┘
                            ↓
┌─────────────────────────────────────────────────────────────┐
│              Client Effect Wrappers                          │
│            settings-client.ts                                │
│  - setLocaleEffect(), getLocaleEffect()                     │
│  - Wraps Server Actions in Effect.tryPromise                │
└─────────────────────────────────────────────────────────────┘
                            ↓
┌─────────────────────────────────────────────────────────────┐
│              Server Actions                                  │
│                 actions.ts                                   │
│  - setLocale(), getLocale()                                 │
│  - Thin wrappers: Effect.runPromise(effectFunction)         │
└─────────────────────────────────────────────────────────────┘
                            ↓
┌─────────────────────────────────────────────────────────────┐
│              Server Effect Logic                             │
│               settings.ts                                    │
│  - setLocaleEffect(), getLocaleEffect()                     │
│  - Uses next/headers cookies()                              │
│  - Uses revalidatePath() for cache invalidation             │
└─────────────────────────────────────────────────────────────┘
                            ↓
┌─────────────────────────────────────────────────────────────┐
│           Server-Side Translation Service                    │
│              locale-server.ts                                │
│  - LocaleServiceServer for SSR components                   │
│  - t() function for translation lookup                      │
│  - Reads locale from cookies                                │
└─────────────────────────────────────────────────────────────┘
```

### File Structure

```
apps/your-app/
├── messages/
│   ├── en.json         # English translations
│   ├── ru.json         # Russian translations
│   └── es.json         # Spanish translations (optional)
├── src/
│   ├── app/
│   │   ├── actions.ts  # Server Actions
│   │   └── layout.tsx  # SSR locale application
│   ├── services/
│   │   ├── locale-server.ts      # Server-side translations
│   │   ├── settings.ts           # Server Effect logic
│   │   └── settings-client.ts    # Client Effect wrappers
│   ├── components/
│   │   └── LanguageSelector.tsx  # UI component
│   └── lib/
│       └── runtime.ts            # Client Effect runtime
```

## Step-by-Step Implementation

### Step 1: Create Translation Files

**`/messages/en.json`**:
```json
{
  "metadata": {
    "title": "Your App - Tagline",
    "description": "Your app description"
  },
  "site": {
    "name": "Your App Name",
    "description": "Short description"
  },
  "hero": {
    "title": "WELCOME",
    "subtitle": "Your subtitle here",
    "cta": {
      "primary": "GET STARTED",
      "secondary": "LEARN MORE"
    }
  },
  "projects": {
    "title": "PROJECTS",
    "sectionLabel": "Featured Work",
    "loading": "Loading projects...",
    "error": "Failed to load projects"
  }
}
```

**`/messages/ru.json`**:
```json
{
  "metadata": {
    "title": "Ваше приложение - Слоган",
    "description": "Описание вашего приложения"
  },
  "site": {
    "name": "Название приложения",
    "description": "Краткое описание"
  },
  "hero": {
    "title": "ДОБРО ПОЖАЛОВАТЬ",
    "subtitle": "Ваш подзаголовок здесь",
    "cta": {
      "primary": "НАЧАТЬ",
      "secondary": "УЗНАТЬ БОЛЬШЕ"
    }
  },
  "projects": {
    "title": "ПРОЕКТЫ",
    "sectionLabel": "Избранные работы",
    "loading": "Загрузка проектов...",
    "error": "Не удалось загрузить проекты"
  }
}
```

### Step 2: Define Types and Errors (Server-Side)

**`/src/services/settings.ts`**:
```typescript
import { Effect, pipe } from "effect";
import * as S from "@effect/schema/Schema";
import { cookies } from "next/headers";
import { revalidatePath } from "next/cache";

export type Locale = "en" | "ru";

export class ServerActionError extends S.TaggedError<ServerActionError>()(
  "ServerActionError",
  {
    message: S.String,
    cause: S.optional(S.Unknown),
  }
) {}

export const setLocaleEffect = (locale: Locale) =>
  pipe(
    Effect.tryPromise({
      try: async () => {
        const cookieStore = await cookies();
        cookieStore.set("locale", locale, {
          path: "/",
          maxAge: 365 * 24 * 60 * 60, // 1 year
          sameSite: "lax",
        });
      },
      catch: (error) =>
        new ServerActionError({
          message: "Failed to set locale cookie",
          cause: error,
        }),
    }),
    Effect.flatMap(() =>
      Effect.tryPromise({
        try: async () => {
          revalidatePath("/");
        },
        catch: (error) =>
          new ServerActionError({
            message: "Failed to revalidate path",
            cause: error,
          }),
      })
    ),
    Effect.tap(() => Effect.log(`Locale set to: ${locale}`))
  );

export const getLocaleEffect = () =>
  pipe(
    Effect.tryPromise({
      try: async (): Promise<Locale> => {
        const cookieStore = await cookies();
        const locale = cookieStore.get("locale")?.value;
        return locale === "en" || locale === "ru" ? locale : "en";
      },
      catch: (error) =>
        new ServerActionError({
          message: "Failed to get locale from cookies",
          cause: error,
        }),
    }),
    Effect.tap((locale) => Effect.log(`Locale retrieved: ${locale}`))
  );
```

### Step 3: Create Server-Side Translation Service

**`/src/services/locale-server.ts`**:
```typescript
import * as S from "@effect/schema/Schema";
import { Context, Effect, Layer } from "effect";
import { cookies } from "next/headers";

// Import translation files
import en from "../../messages/en.json";
import ru from "../../messages/ru.json";

export const LocaleSchema = S.Literal("en", "ru");
export type Locale = S.Schema.Type<typeof LocaleSchema>;

export class LocaleError extends S.TaggedError<LocaleError>()(
  "LocaleError",
  { message: S.String, cause: S.optional(S.Unknown) }
) {}

export class TranslationError extends S.TaggedError<TranslationError>()(
  "TranslationError",
  { key: S.String, locale: S.String, message: S.String }
) {}

export interface LocaleServiceServer {
  readonly getLocale: () => Effect.Effect<Locale, LocaleError>;
  readonly t: (key: string) => Effect.Effect<string, TranslationError | LocaleError>;
}

export const LocaleServiceServerTag = Context.GenericTag<LocaleServiceServer>(
  "@yourapp/LocaleServiceServer"
);

const messages = { en, ru } as const;

// Helper to get nested values from JSON
function getNestedValue(obj: unknown, path: string): string {
  const keys = path.split(".");
  let current: unknown = obj;

  for (const key of keys) {
    if (
      typeof current === "object" &&
      current !== null &&
      key in current
    ) {
      current = (current as Record<string, unknown>)[key];
    } else {
      return path; // Return key if not found
    }
  }

  return typeof current === "string" ? current : path;
}

export const LocaleServiceServerLive = Layer.succeed(LocaleServiceServerTag, {
  getLocale: () =>
    Effect.tryPromise({
      try: async (): Promise<Locale> => {
        const cookieStore = await cookies();
        const locale = cookieStore.get("locale")?.value;
        if (locale === "en" || locale === "ru") return locale;
        return "en";
      },
      catch: (error) => new LocaleError({
        message: "Failed to get locale from cookies",
        cause: error,
      }),
    }),

  t: (key: string) =>
    Effect.gen(function* () {
      const cookieStore = yield* Effect.promise(() => cookies());
      const locale = cookieStore.get("locale")?.value;
      const currentLocale = (locale === "en" || locale === "ru") ? locale : "en";

      const translation = getNestedValue(messages[currentLocale], key);
      if (translation === key) {
        return yield* Effect.fail(
          new TranslationError({
            key,
            locale: currentLocale,
            message: `Translation not found for key: ${key}`,
          })
        );
      }
      return translation;
    }),
});
```

### Step 4: Create Server Actions

**`/src/app/actions.ts`**:
```typescript
"use server";

import { Effect } from "effect";
import {
  setLocaleEffect,
  getLocaleEffect,
  type Locale,
} from "@/services/settings";

export type { Locale };

export async function setLocale(locale: Locale) {
  return Effect.runPromise(setLocaleEffect(locale));
}

export async function getLocale(): Promise<Locale> {
  return Effect.runPromise(getLocaleEffect());
}
```

### Step 5: Create Client Effect Wrappers

**`/src/services/settings-client.ts`**:
```typescript
import { Effect, pipe } from "effect";
import * as S from "@effect/schema/Schema";

export type Locale = "en" | "ru";

export class ServerActionError extends S.TaggedError<ServerActionError>()(
  "ServerActionError",
  {
    message: S.String,
    cause: S.optional(S.Unknown),
  }
) {}

export const setLocaleEffect = (locale: Locale) =>
  pipe(
    Effect.tryPromise({
      try: async () => {
        const { setLocale } = await import("@/app/actions");
        await setLocale(locale);
      },
      catch: (error) =>
        new ServerActionError({
          message: "Failed to set locale",
          cause: error,
        }),
    }),
    Effect.tap(() => Effect.log(`Locale set to: ${locale}`))
  );

export const getLocaleEffect = () =>
  pipe(
    Effect.tryPromise({
      try: async (): Promise<Locale> => {
        const { getLocale } = await import("@/app/actions");
        return getLocale();
      },
      catch: (error) =>
        new ServerActionError({
          message: "Failed to get locale",
          cause: error,
        }),
    }),
    Effect.tap((locale) => Effect.log(`Locale retrieved: ${locale}`))
  );
```

### Step 6: Create Client Runtime Helper

**`/src/lib/runtime.ts`**:
```typescript
import { Runtime, type Effect } from "effect";

export const clientRuntime = Runtime.defaultRuntime;

export function runClientEffect<A, E>(
  effect: Effect.Effect<A, E>
): Promise<A> {
  return Runtime.runPromise(clientRuntime)(effect);
}
```

### Step 7: Update Layout for SSR Locale

**`/src/app/layout.tsx`**:
```typescript
import { cookies } from "next/headers";

export default async function RootLayout({
  children,
}: Readonly<{ children: React.ReactNode; }>) {
  const cookieStore = await cookies();
  const locale = cookieStore.get("locale")?.value || "en";

  return (
    <html lang={locale}>
      <body className="antialiased">
        {children}
      </body>
    </html>
  );
}
```

### Step 8: Create Language Selector Component

**`/src/components/LanguageSelector.tsx`**:
```typescript
"use client";

import { Globe } from "lucide-react";
import { useEffect, useState } from "react";
import { Effect, pipe } from "effect";
import {
  getLocaleEffect,
  setLocaleEffect,
  type Locale,
} from "@/services/settings-client";
import { runClientEffect } from "@/lib/runtime";

const LOCALES: { value: Locale; label: string }[] = [
  { value: "en", label: "EN" },
  { value: "ru", label: "RU" },
];

export function LanguageSelector() {
  const [isOpen, setIsOpen] = useState(false);
  const [currentLocale, setCurrentLocale] = useState<Locale>("en");

  useEffect(() => {
    const program = pipe(
      getLocaleEffect(),
      Effect.tap((locale) => Effect.sync(() => setCurrentLocale(locale)))
    );

    void runClientEffect(program);
  }, []);

  const handleSelect = (locale: Locale) => {
    setIsOpen(false);
    setCurrentLocale(locale);

    const program = pipe(
      setLocaleEffect(locale),
      Effect.tap(() => Effect.log(`Language changed to: ${locale}`))
    );

    void runClientEffect(program);
  };

  const currentLabel =
    LOCALES.find((l) => l.value === currentLocale)?.label || "EN";

  return (
    <div className="relative">
      <button
        onClick={() => setIsOpen(!isOpen)}
        className="h-12 min-w-12 px-3 border-2 border-border bg-background/90 backdrop-blur-sm text-foreground hover:border-primary hover:bg-primary/10 transition-all duration-300 flex items-center gap-2"
        aria-label="Select language"
      >
        <Globe className="w-5 h-5" />
        <span className="text-xs font-bold tracking-wider">{currentLabel}</span>
      </button>

      {isOpen && (
        <>
          <div
            className="fixed inset-0 z-40"
            onClick={() => setIsOpen(false)}
          />
          <div className="absolute right-0 mt-2 w-24 border-2 border-border bg-background shadow-lg z-50">
            {LOCALES.map((locale) => (
              <button
                key={locale.value}
                onClick={() => handleSelect(locale.value)}
                className={`w-full h-10 px-4 text-sm font-bold uppercase tracking-wider transition-all duration-200 border-b border-border last:border-b-0 ${
                  currentLocale === locale.value
                    ? "bg-primary text-primary-foreground"
                    : "text-foreground hover:bg-primary hover:text-primary-foreground"
                }`}
              >
                {locale.label}
              </button>
            ))}
          </div>
        </>
      )}
    </div>
  );
}
```

## Usage Patterns

### Server Components with LocaleServiceServer

```typescript
import { Effect, pipe } from "effect";
import { LocaleServiceServerTag, LocaleServiceServerLive } from "@/services/locale-server";

export default async function Page() {
  const titleProgram = pipe(
    LocaleServiceServerTag,
    Effect.flatMap(service => service.t("hero.title")),
    Effect.provide(LocaleServiceServerLive)
  );

  const title = await Effect.runPromise(titleProgram);

  return <h1>{title}</h1>;
}
```

### Using with Content Services

Create a ContentService that depends on LocaleServiceServer:

```typescript
import { Context, Effect, Layer, pipe } from "effect";
import { LocaleServiceServerTag } from "@/services/locale-server";

export interface ContentService {
  readonly getHeroTitle: () => Effect.Effect<string, never>;
  readonly getProjectsTitle: () => Effect.Effect<string, never>;
}

export const ContentServiceTag = Context.GenericTag<ContentService>(
  "@yourapp/ContentService"
);

export const ContentServiceLive = Layer.effect(
  ContentServiceTag,
  Effect.gen(function* () {
    const localeService = yield* LocaleServiceServerTag;

    return {
      getHeroTitle: () =>
        pipe(
          localeService.t("hero.title"),
          Effect.catchAll(() => Effect.succeed("Welcome"))
        ),
      getProjectsTitle: () =>
        pipe(
          localeService.t("projects.title"),
          Effect.catchAll(() => Effect.succeed("Projects"))
        ),
    };
  })
);

// Usage in page
const AppLayer = Layer.provide(ContentServiceLive, LocaleServiceServerLive);

export default async function Page() {
  const program = pipe(
    ContentServiceTag,
    Effect.flatMap(service => service.getHeroTitle()),
    Effect.provide(AppLayer)
  );

  const title = await Effect.runPromise(program);
  return <h1>{title}</h1>;
}
```

## Effect-TS Patterns

### 1. Server-Side Effects with next/headers

```typescript
export const setLocaleEffect = (locale: Locale) =>
  pipe(
    Effect.tryPromise({
      try: async () => {
        const cookieStore = await cookies(); // Next.js 15 async cookies
        cookieStore.set("locale", locale, { /* ... */ });
      },
      catch: (error) => new ServerActionError({ /* ... */ })
    }),
    Effect.flatMap(() => /* revalidate */),
    Effect.tap(() => Effect.log(/* ... */))
  );
```

### 2. Client-Side Effect Wrappers

```typescript
export const setLocaleEffect = (locale: Locale) =>
  pipe(
    Effect.tryPromise({
      try: async () => {
        const { setLocale } = await import("@/app/actions"); // Dynamic import
        await setLocale(locale);
      },
      catch: (error) => new ServerActionError({ /* ... */ })
    }),
    Effect.tap(() => Effect.log(/* ... */))
  );
```

### 3. Translation with Fallback

```typescript
localeService.t("hero.title"),
Effect.catchAll(() => Effect.succeed("Default Title"))
```

## Adding New Locales

### 1. Create Translation File

**`/messages/es.json`**:
```json
{
  "metadata": {
    "title": "Tu Aplicación - Lema",
    "description": "Descripción de tu aplicación"
  },
  "hero": {
    "title": "BIENVENIDO",
    "subtitle": "Tu subtítulo aquí"
  }
}
```

### 2. Update Type Definition

```typescript
export type Locale = "en" | "ru" | "es";
```

### 3. Import in Services

**locale-server.ts**:
```typescript
import es from "../../messages/es.json";
const messages = { en, ru, es } as const;
```

### 4. Update Schema

```typescript
export const LocaleSchema = S.Literal("en", "ru", "es");
```

### 5. Update UI Component

```typescript
const LOCALES = [
  { value: "en", label: "EN" },
  { value: "ru", label: "RU" },
  { value: "es", label: "ES" },
];
```

## Best Practices

### 1. Translation Key Organization

Use nested keys for logical grouping:
```json
{
  "page": {
    "hero": {
      "title": "...",
      "subtitle": "..."
    },
    "features": {
      "title": "...",
      "items": {
        "item1": "...",
        "item2": "..."
      }
    }
  }
}
```

Access with dot notation: `t("page.hero.title")`

### 2. Always Provide Fallbacks

```typescript
pipe(
  localeService.t("some.key"),
  Effect.catchAll(() => Effect.succeed("Default Value"))
)
```

### 3. Consistent Naming

- Service tag: `LocaleServiceServerTag`
- Cookie name: `"locale"`
- Translation function: `t()`
- Messages directory: `/messages/`

### 4. Cookie Configuration

Set long expiration for locale preference:
```typescript
cookieStore.set("locale", locale, {
  path: "/",
  maxAge: 365 * 24 * 60 * 60, // 1 year
  sameSite: "lax",
});
```

### 5. Type Safety

Use Effect Schema for locale validation:
```typescript
export const LocaleSchema = S.Literal("en", "ru", "es");
export type Locale = S.Schema.Type<typeof LocaleSchema>;
```

## Testing

- [ ] Locale switches without page reload
- [ ] Current locale displayed in selector
- [ ] Current locale highlighted in dropdown
- [ ] SSR works (disable JS, locale from cookie persists)
- [ ] Cookie set correctly (check DevTools)
- [ ] Translations load correctly for each locale
- [ ] Missing keys return key as fallback
- [ ] Build passes: `bun run build`
- [ ] Lint passes: `bun run lint`
- [ ] Effect.log outputs visible in console

## Troubleshooting

### "Cannot find module 'next/headers'" in Client

**Cause**: Client component importing server-only module.

**Fix**: Ensure client components only import from `settings-client.ts`, not `settings.ts` or `locale-server.ts`.

### Missing Translations Return Key Instead of Value

**Cause**: Key not found in JSON or incorrect nesting.

**Fix**:
1. Check JSON structure matches key path
2. Verify all locales have the same keys
3. Use fallback in code:
```typescript
Effect.catchAll(() => Effect.succeed("Default Text"))
```

### Locale Not Persisting

**Cause**: Cookie not being set properly.

**Fix**: Check cookie in DevTools → Application → Cookies. Ensure:
- Name is exactly `"locale"`
- Value is valid locale (`"en"`, `"ru"`, etc.)
- Path is `"/"`
- Expiration is set

### TypeScript Error: Type '"es"' is not assignable to type 'Locale'

**Cause**: Added new locale but didn't update type.

**Fix**: Update LocaleSchema and type definition:
```typescript
export const LocaleSchema = S.Literal("en", "ru", "es");
export type Locale = S.Schema.Type<typeof LocaleSchema>;
```

## Migration from next-intl

If you're migrating from `next-intl`:

1. **Remove next-intl:**
   ```bash
   bun remove next-intl
   ```

2. **Keep translation files:**
   - Keep `/messages/*.json` structure
   - Keep JSON nested structure

3. **Replace hooks:**
   - `useTranslations()` → Use LanguageSelector + SSR
   - `getTranslations()` → Use LocaleServiceServer in server components

4. **Update routing:**
   - Remove `[locale]` segment (unless you want URL-based routing)
   - Locale now stored in cookies

5. **Update middleware:**
   - Remove next-intl middleware
   - Add optional middleware for locale header (see above)

## Reference Implementation

Working implementation: `@apps/mtlprog.xyz`

Key files:
- `/messages/en.json`, `/messages/ru.json` - Translation files
- `/src/services/locale-server.ts` - Server-side translations
- `/src/services/settings.ts` - Server Effect logic
- `/src/services/settings-client.ts` - Client Effect wrappers
- `/src/app/actions.ts` - Server Actions
- `/src/lib/runtime.ts` - Client runtime
- `/src/components/LanguageSelector.tsx` - Language dropdown
- `/src/app/layout.tsx` - SSR locale application

## Advantages Over Library-Based Solutions

### vs next-intl

| Feature | Dreadnought i18n | next-intl |
|---------|------------------|-----------|
| Type safety | Effect Schema validation | TypeScript augmentation |
| Error handling | Effect error types | Promise rejection |
| Dependencies | Zero (uses Effect-TS) | External library |
| Routing | Cookie-based | URL segment-based |
| SSR | Native with next/headers | Requires setup |
| Consistency | Matches Dreadnought patterns | Different paradigm |
| Bundle size | Smaller (no extra deps) | Larger |

### vs react-i18next

| Feature | Dreadnought i18n | react-i18next |
|---------|------------------|---------------|
| Paradigm | Functional (Effect-TS) | Imperative hooks |
| Configuration | Effect Layer | i18next config |
| Server support | Native Effect runtime | Requires setup |
| Type safety | Schema-based | Manual typing |

## Further Reading

- [Effect-TS Documentation](https://effect.website/docs/introduction)
- [Next.js 15 Server Actions](https://nextjs.org/docs/app/building-your-application/data-fetching/server-actions-and-mutations)
- [Next.js Internationalization](https://nextjs.org/docs/app/building-your-application/routing/internationalization)
- [Theme Switching Guide](/docs/guides/theme-switching.md) - Complementary guide for theme management
