# Internationalization (i18n) Guide for Dreadnought

This guide describes the Dreadnought approach to internationalization using **Effect-TS** for a type-safe, functional i18n implementation.

## Table of Contents

1. [Overview](#overview)
2. [Architecture](#architecture)
3. [Implementation](#implementation)
4. [Usage Patterns](#usage-patterns)
5. [Best Practices](#best-practices)
6. [Migration from next-intl](#migration-from-next-intl)

## Overview

### Why Custom Effect-TS i18n?

Instead of using libraries like `next-intl` or `react-i18next`, Dreadnought implements a **custom Effect-TS-based i18n solution** that:

- ✅ **Type-safe translations** with Effect schema validation
- ✅ **Functional error handling** using Effect error types
- ✅ **Browser locale detection** with fallback strategies
- ✅ **Cookie-based persistence** with localStorage migration
- ✅ **Nested translation keys** with dot notation (`"hero.title"`)
- ✅ **No external i18n dependencies** - full control over implementation
- ✅ **Consistent with Dreadnought Effect-TS patterns**

### Supported Features

- Multiple locale support (e.g., `en`, `ru`)
- Browser language detection
- Cookie storage with automatic localStorage migration
- Nested JSON translation files
- Server and client component support
- Type-safe locale values using Effect Schema

## Architecture

### File Structure

```
apps/your-app/
├── messages/
│   ├── en.json         # English translations
│   └── ru.json         # Russian translations
├── src/
│   └── services/
│       └── locale.ts   # LocaleService implementation
```

### Core Components

1. **LocaleService** - Effect service for locale management
2. **Translation Files** - JSON files with nested translation keys
3. **Schema Validation** - Effect schemas for locale values
4. **Error Types** - Tagged errors for cookie, locale, and translation errors

## Implementation

### Step 1: Define Locale Schema

```typescript
import * as S from "@effect/schema/Schema";
import { Context, Effect, Layer, pipe } from "effect";

// Define supported locales
const LocaleSchema = S.Literal("en", "ru");
export type Locale = S.Schema.Type<typeof LocaleSchema>;
export { LocaleSchema as Locale };
```

### Step 2: Define Error Types

```typescript
export class CookieError extends S.TaggedError<CookieError>()(
  "CookieError",
  {
    operation: S.String,
    message: S.String,
    cause: S.optional(S.Unknown),
  },
) {}

export class LocaleError extends S.TaggedError<LocaleError>()(
  "LocaleError",
  {
    message: S.String,
    cause: S.optional(S.Unknown),
  },
) {}

export class TranslationError extends S.TaggedError<TranslationError>()(
  "TranslationError",
  {
    key: S.String,
    locale: S.String,
    message: S.String,
  },
) {}
```

### Step 3: Define LocaleService Interface

```typescript
export interface LocaleService {
  readonly getLocale: Effect.Effect<Locale, LocaleError>;
  readonly setLocale: (locale: Locale) => Effect.Effect<void, CookieError>;
  readonly t: (key: string) => Effect.Effect<string, TranslationError | LocaleError>;
  readonly detectBrowserLocale: Effect.Effect<Locale, LocaleError>;
}

export const LocaleServiceTag = Context.GenericTag<LocaleService>(
  "@your-app/LocaleService"
);
```

### Step 4: Implement Helper Effects

```typescript
// Cookie operations
const getCookieEffect = (name: string): Effect.Effect<string | null, CookieError> =>
  pipe(
    Effect.try({
      try: () => {
        if (typeof document === "undefined") return null;
        const value = `; ${document.cookie}`;
        const parts = value.split(`; ${name}=`);
        if (parts.length === 2) return parts.pop()?.split(";").shift() ?? null;
        return null;
      },
      catch: (error) =>
        new CookieError({
          operation: "read",
          message: `Failed to read cookie: ${name}`,
          cause: error,
        }),
    }),
  );

const setCookieEffect = (
  name: string,
  value: string,
  days: number = 365
): Effect.Effect<void, CookieError> =>
  pipe(
    Effect.try({
      try: () => {
        if (typeof document === "undefined") return;
        const expires = new Date();
        expires.setTime(expires.getTime() + (days * 24 * 60 * 60 * 1000));
        document.cookie = `${name}=${value};expires=${expires.toUTCString()};path=/`;
      },
      catch: (error) =>
        new CookieError({
          operation: "write",
          message: `Failed to set cookie: ${name}`,
          cause: error,
        }),
    }),
  );

// Browser language detection
const getBrowserLanguageEffect = (): Effect.Effect<Locale, LocaleError> =>
  pipe(
    Effect.try({
      try: (): Locale => {
        if (typeof globalThis === "undefined" || typeof globalThis.navigator === "undefined") {
          return "en";
        }
        const lang = globalThis.navigator.language.slice(0, 2);
        return lang === "ru" ? "ru" : "en";
      },
      catch: (error) =>
        new LocaleError({
          message: "Failed to get browser language",
          cause: error,
        }),
    }),
  );

// Nested translation key access
const getNestedValue = (obj: Readonly<Record<string, unknown>>, path: string): string => {
  const result = path.split(".").reduce((current: unknown, key: string) => {
    if (current !== null && typeof current === "object" && key in (current as Record<string, unknown>)) {
      return (current as Record<string, unknown>)[key];
    }
    return undefined;
  }, obj);
  return typeof result === "string" ? result : path;
};
```

### Step 5: Create Translation Files

**messages/en.json:**
```json
{
  "metadata": {
    "title": "Your App - Tagline",
    "description": "Your app description"
  },
  "hero": {
    "title": "WELCOME",
    "subtitle": "Your subtitle here",
    "cta": {
      "primary": "GET STARTED",
      "secondary": "LEARN MORE"
    }
  },
  "projects": {
    "title": "PROJECTS",
    "loading": "Loading projects...",
    "error": "Failed to load projects"
  }
}
```

**messages/ru.json:**
```json
{
  "metadata": {
    "title": "Ваше приложение - Слоган",
    "description": "Описание вашего приложения"
  },
  "hero": {
    "title": "ДОБРО ПОЖАЛОВАТЬ",
    "subtitle": "Ваш подзаголовок здесь",
    "cta": {
      "primary": "НАЧАТЬ",
      "secondary": "УЗНАТЬ БОЛЬШЕ"
    }
  },
  "projects": {
    "title": "ПРОЕКТЫ",
    "loading": "Загрузка проектов...",
    "error": "Не удалось загрузить проекты"
  }
}
```

### Step 6: Implement LocaleServiceLive

```typescript
// Import translation files
import en from "../../messages/en.json";
import ru from "../../messages/ru.json";

const messages = { en, ru } as const;

export const LocaleServiceLive = Layer.succeed(LocaleServiceTag, {
  getLocale: pipe(
    getCookieEffect("locale"),
    Effect.map(cookieValue => {
      if (cookieValue === "en" || cookieValue === "ru") {
        return cookieValue;
      }
      return "en" as Locale;
    }),
    Effect.catchAll(() => Effect.succeed<Locale>("en")),
  ),

  setLocale: (locale: Locale) => setCookieEffect("locale", locale),

  t: (key: string) =>
    pipe(
      getCookieEffect("locale"),
      Effect.map(cookieValue => {
        const locale = (cookieValue === "en" || cookieValue === "ru") ? cookieValue : "en";
        return getNestedValue(messages[locale], key);
      }),
      Effect.mapError(() =>
        new TranslationError({
          key,
          locale: "en",
          message: `Failed to translate key: ${key}`,
        })
      ),
    ),

  detectBrowserLocale: pipe(
    getCookieEffect("locale"),
    Effect.flatMap(cookieValue => {
      // Return cookie locale if valid
      if (cookieValue === "en" || cookieValue === "ru") {
        return Effect.succeed<Locale>(cookieValue);
      }

      // Check localStorage for migration (optional)
      // Use browser language detection
      return pipe(
        getBrowserLanguageEffect(),
        Effect.flatMap(browserLang =>
          pipe(
            setCookieEffect("locale", browserLang),
            Effect.map((): Locale => browserLang),
            Effect.catchAll(() => Effect.succeed<Locale>(browserLang)),
          )
        ),
      );
    }),
    Effect.catchAll(() => Effect.succeed<Locale>("en")),
  ),
});
```

## Usage Patterns

### Client Components

```typescript
"use client";

import { Effect, pipe } from "effect";
import { LocaleServiceTag } from "@/services/locale";
import { use, useEffect, useState } from "react";

export function LocalizedComponent() {
  const [title, setTitle] = useState("Loading...");

  useEffect(() => {
    const program = pipe(
      LocaleServiceTag,
      Effect.flatMap(service => service.t("hero.title"))
    );

    // Run Effect program
    Effect.runPromise(program).then(setTitle).catch(console.error);
  }, []);

  return <h1>{title}</h1>;
}
```

### Server Components

```typescript
import { Effect, Layer, pipe } from "effect";
import { LocaleServiceTag, LocaleServiceLive } from "@/services/locale";

const AppLayer = Layer.merge(LocaleServiceLive, /* other layers */);

export default async function Page() {
  const titleProgram = pipe(
    LocaleServiceTag,
    Effect.flatMap(service => service.t("hero.title")),
    Effect.provide(AppLayer)
  );

  const title = await Effect.runPromise(titleProgram);

  return <h1>{title}</h1>;
}
```

### Language Switcher Component

```typescript
"use client";

import { Effect, pipe } from "effect";
import { LocaleServiceTag, type Locale } from "@/services/locale";

export function LanguageSwitcher() {
  const switchLocale = (newLocale: Locale) => {
    const program = pipe(
      LocaleServiceTag,
      Effect.flatMap(service => service.setLocale(newLocale))
    );

    Effect.runPromise(program)
      .then(() => window.location.reload())
      .catch(console.error);
  };

  return (
    <div>
      <button onClick={() => switchLocale("en")}>EN</button>
      <button onClick={() => switchLocale("ru")}>RU</button>
    </div>
  );
}
```

### Detect and Set Browser Locale on Mount

```typescript
"use client";

import { Effect, pipe } from "effect";
import { LocaleServiceTag } from "@/services/locale";
import { useEffect } from "react";

export function LocaleDetector() {
  useEffect(() => {
    const program = pipe(
      LocaleServiceTag,
      Effect.flatMap(service => service.detectBrowserLocale)
    );

    Effect.runPromise(program).catch(console.error);
  }, []);

  return null;
}
```

## Best Practices

### 1. Translation Key Organization

**Use nested keys for logical grouping:**
```json
{
  "page": {
    "hero": {
      "title": "...",
      "subtitle": "..."
    },
    "features": {
      "title": "...",
      "item1": "..."
    }
  }
}
```

Access with dot notation: `t("page.hero.title")`

### 2. Error Handling

Always handle translation errors gracefully:

```typescript
const titleProgram = pipe(
  LocaleServiceTag,
  Effect.flatMap(service => service.t("hero.title")),
  Effect.catchAll(error => Effect.succeed("Default Title"))
);
```

### 3. Type Safety

Use Effect Schema for locale validation:

```typescript
const LocaleSchema = S.Literal("en", "ru", "es", "de");
export type Locale = S.Schema.Type<typeof LocaleSchema>;
```

### 4. Consistent Naming

- **Service tag**: `LocaleServiceTag`
- **Cookie name**: `"locale"`
- **Translation function**: `t()`
- **Messages directory**: `/messages/`

### 5. Fallback Strategy

Always provide fallback to default locale:

```typescript
Effect.catchAll(() => Effect.succeed<Locale>("en"))
```

### 6. Cookie Configuration

Set long expiration for locale preference:

```typescript
setCookieEffect("locale", locale, 365) // 1 year
```

## Migration from next-intl

If you're migrating from `next-intl`:

1. **Remove next-intl dependencies:**
   ```bash
   bun remove next-intl
   ```

2. **Move translation files:**
   - Keep `/messages/*.json` structure
   - Keep JSON nested structure

3. **Replace components:**
   - `useTranslations()` → Use LocaleService with `t()`
   - `getTranslations()` → Use LocaleService in server components
   - `NextIntlClientProvider` → Not needed

4. **Update middleware:**
   - Remove next-intl middleware
   - Locale detection handled by LocaleService

5. **Update routing:**
   - No `[locale]` segment needed (unless you want URL-based routing)
   - Locale stored in cookies instead

## Adding New Locales

1. **Add to LocaleSchema:**
   ```typescript
   const LocaleSchema = S.Literal("en", "ru", "es"); // Add "es"
   ```

2. **Create translation file:**
   ```bash
   touch messages/es.json
   ```

3. **Import in LocaleService:**
   ```typescript
   import es from "../../messages/es.json";
   const messages = { en, ru, es } as const;
   ```

4. **Update browser detection:**
   ```typescript
   const lang = globalThis.navigator.language.slice(0, 2);
   return lang === "ru" ? "ru" : lang === "es" ? "es" : "en";
   ```

## Advantages Over Library-Based Solutions

### vs next-intl

| Feature | Dreadnought i18n | next-intl |
|---------|------------------|-----------|
| Type safety | Effect Schema validation | TypeScript augmentation |
| Error handling | Effect error types | Promise rejection |
| Dependencies | Zero (uses Effect-TS) | External library |
| Routing | Cookie-based | URL segment-based |
| Consistency | Matches Dreadnought patterns | Different paradigm |
| Bundle size | Smaller (no extra deps) | Larger |

### vs react-i18next

| Feature | Dreadnought i18n | react-i18next |
|---------|------------------|---------------|
| Paradigm | Functional (Effect-TS) | Imperative hooks |
| Configuration | Effect Layer | i18next config |
| Server support | Native Effect runtime | Requires setup |
| Type safety | Schema-based | Manual typing |

## Conclusion

The Dreadnought i18n approach provides:

- ✅ Full Effect-TS integration
- ✅ Type-safe locale and translation management
- ✅ Functional error handling
- ✅ Zero external i18n dependencies
- ✅ Consistent with project architecture
- ✅ Simple cookie-based persistence

This pattern ensures that internationalization follows the same Effect-TS principles as the rest of the Dreadnought codebase, maintaining consistency and type safety throughout the application.